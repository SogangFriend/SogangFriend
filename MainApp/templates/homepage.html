{% extends 'base.html' %}
{% load static %}
{% block content %}
<div>
    <div class="left" id="left">
        <div class="left_header">
            <p style="font-size: 13px; text-align:center; font-weight:bold; padding-top:15px; ">나와 관심사가 같은 서강대생을 찾아 이야기를 나누어 보세요!</p>
        </div>
        <div class="tab_menu">
            <div class="list">
                <li class="is_on">
                    <a href="#people" class="btn">People</a>
                </li>

                <li>
                    <a href="#chat" class="btn">Chat</a>
                </li>
            </div>
{#        </div>#}
{#                        </div>#}
            <div class="left_body" id="left_body">
    {#                                <p style="padding-top:-10%; padding-bottom:-10%;">My</p>#}
                {% for member in members %}
                    <div id="people" class="lb_profile" style="display:block;">
                        <div class="people_img">
                            <img src="/static/images/default_profile.png" alt="sogang">
                            {{ member.profile_photo }}
                        </div>
                        {{ member.name }}
                        <span_studentN>{{ member.student_number }}학번</span_studentN>
                        <a href="{% url 'Chat:dm'  pk=member.pk %}" style="color: #F5D300; font-size:13px; float:right;">Dm 보내기</a>
                        <p class="people_info_txt">{{ member.location.si }} {{ member.location.gu }} {{ member.location.dong }}<br>
                                                    한줄소개: {{ member.introduction }}
                        </p>

                    </div>
                {% endfor %}
                <div id="chat" class="lb_profile" style="display:none;">
                    <button type="button" class="btn_chatroom" onclick="createChatRoom()">채팅방+</button>
                </div>
                {% for chat in chats %}
                    <div id="chat" class="lb_profile" style="display:none;">
                        <div class="people_img">
    {#                                     <img src="/static/images/default_profile.png" alt="sogang">#}
                            {{ profile_photo }}
                        </div>
                        {{ chat.name }} <span_studentN>{{ chat.creator.name }}</span_studentN><br>
                        <button class="btn_chatroom" onclick="location.href='{% url 'Chat:dm'  pk=chat.pk %}'">입장하기</button>
                        <p class="people_info_txt">
                            <br>
                            인원 : {{ chat.participants.count }}명
                        </p>
                    </div>
                {% endfor %}

            </div>
        </div>
    </div>

    <div class="right">
        <div class="member_info" style="height: 5%; float: left;">
                <input type="radio" name="range" id="gu" onclick="clickCheck(this.id)" checked="checked" style="margin-top: 20px; margin-left: 5px"/> <span>구까지 범위 표시</span>
                <input type="radio" name="range" id="dong" onclick="clickCheck(this.id)"/> <span>동까지 범위 표시</span>
        </div>
        <div id="map" style="width:100%; height: 95%; display: block;"></div>
        <!-- 지도타입 컨트롤 div 입니다 -->
    </div>
</div>
<script>
    const jsonStr = "{{ json_data | escapejs }}".replaceAll("\'", "\"");
    const data = JSON.parse(jsonStr)['location'];
    const centerStr = "{{ center | escapejs }}".replaceAll("\'", "\"");
    const center = JSON.parse(centerStr);
    let polygons = [];
    let container = document.getElementById('map'); //지도를 담을 영역의 DOM 레퍼런스

    let options = { //지도를 생성할 때 필요한 기본 옵션
        center: new kakao.maps.LatLng(center['lat'], center['lng']), //지도의 중심좌표.
        level: 6 //지도의 레벨(확대, 축소 정도)
    };
    let map = new kakao.maps.Map(container, options); //지도 생성 및 객체 리턴
    drawLocation(true);

    map.setZoomable(false);
    map.setDraggable(false);

    var customOverlay = new kakao.maps.CustomOverlay({
        map: map,
        content: '<div style="padding: 5px; background:#fff;">' +
            '내 위치: {{ member_info.location.si }} {{ member_info.location.gu }} {{ member_info.location.dong }}' +
            '</div>',
        position: new kakao.maps.LatLng(37.462932227677896, 126.899851798148), // 커스텀 오버레이를 표시할 좌표 - 항상 맵 위의 고정 위치에 띄울 방법...?
        xAnchor: 0, // 컨텐츠의 x 위치
        yAnchor: 13 // 컨텐츠의 y 위치
    });
        // 지도 확대 축소를 제어할 수 있는  줌 컨트롤을 생성합니다
    let zoomControl = new kakao.maps.ZoomControl();
    map.addControl(zoomControl, kakao.maps.ControlPosition.RIGHT);

    function clickCheck(id) {
        for (let i = 0; i < polygons.length; i++) {
            polygons[i].setMap(null);
        }
        polygons = [];

        id === "gu" ? drawLocation(true)
                    : drawLocation(false);
    }

    function drawLocation(guFlag) {
        let dongName= '{{ member_info.location.dong }}';
        dongName = dongName.slice(0, dongName.length-1);
        if(!guFlag) {
            for (let i = 0; i < data.length; i++) {
                if(data[i]['name'].includes(dongName)) {
                    displayArea(guFlag, data[i]['coords']);
                }
            }
        } else {
            for (let i = 0; i < data.length; i++) {
                displayArea(guFlag, data[i]['coords']);
            }
        }

        for (let i = 0; i < polygons.length; i++) {
            polygons[i].setMap(map);
        }
    }

    function displayArea(guFlag, coordinates) {
        polygons.push(makeMultiPolygon(guFlag, coordinates));
    }

    function makeMultiPolygon(guFlag, coordinates) {
        let paths = [];
        $.each(coordinates, function (index, val) {
            let coordinates2 = [];

            $.each(val[0], function (index2, coordinate) {
                coordinates2.push(new kakao.maps.LatLng(coordinate[1], coordinate[0]));
            });
            paths.push(coordinates2);
        });

        return new kakao.maps.Polygon({
            path: paths,
            strokeWeight: 5,
            strokeColor: guFlag ? '#FFBB00' : '#ff5900',
            strokeOpacity: 1,
            strokeStyle: 'solid',
            fillColor: guFlag ? '#FFE271' : '#ff7d3c',
            fillOpacity: 0.5
        });
    }

    const tabList = document.querySelectorAll('.tab_menu .list li');
    const contents = document.querySelectorAll('.tab_menu .left_body .lb_profile')
    let activeCont = ''; // 현재 활성화 된 컨텐츠 (기본:#tab1 활성화)

    for(var i = 0; i < tabList.length; i++) {
        tabList[i].querySelector('.btn').addEventListener('click', function (e) {
            e.preventDefault();
            for (var j = 0; j < contents.length; j++) {
                // 나머지 버튼 클래스 제거
                if (j < tabList.length) tabList[j].classList.remove('is_on');

                // 나머지 컨텐츠 display:none 처리
                contents[j].style.display = 'none';

            }

            // 버튼 관련 이벤트
            this.parentNode.classList.add('is_on');

            // 버튼 클릭시 컨텐츠 전환
            activeCont = this.getAttribute('href');
            let l = document.querySelectorAll(activeCont);

            for (let j = 0; j < l.length; j++) {
                l[j].style.display = 'block';
                console.log(l[j]);
            }
        });
    }

    function createChatRoom() {
        Swal.fire({
            title: '새 채팅방 생성',
            html: '<input type="text" id="chat_name" class="swal2-input" placeholder="채팅방 이름">',
            confirmButtonText: '생성',
            focusConfirm: false,
            preConfirm: () => {
               const name = Swal.getPopup().querySelector('#chat_name').value;
               if (!name) {
                   Swal.showValidationMessage('이름을 입력해주세요');
               }
               return { name: name }
           }
        }).then((result) => {
            let csrftoken = getCookie('csrftoken');
            let data = {'name': result.value.name, };
            console.log(data);
            $.ajax({

                beforeSend: function(xhr, settings) {
                    if (!csrfSafeMethod(settings.type) && !this.crossDomain) {
                        xhr.setRequestHeader("X-CSRFToken", csrftoken);
                    }
                },
                url: "{% url 'Chat:new' %}",
                method: "POST",
                data: JSON.stringify(data),
                processData: false,
                contentType: false,
                dataType: 'json',
            }).done((data) => {
                console.log("chat create result : ", data);
                Swal.fire({
                    icon: 'success',
                    html: data['message'],
                    buttonsStyling:false,
                    confirmButtonText: "확인",
                    width: '672px',

                    customClass : {
                        confirmButton: 'swal-register-btn',
                        popup: 'swal-custom-container'
                    },
                });
                location.reload();
            }).fail((data, status, error) => {
                Swal.fire({
                    icon: 'error',
                    html: status + ": " + error,
                    buttonsStyling:false,
                    confirmButtonText: "확인",
                    width: '672px',

                    customClass : {
                        confirmButton: 'swal-register-btn',
                        popup: 'swal-custom-container'
                    },
                });
            });
        });
    }


    // using jQuery
    function getCookie(name) {
        var cookieValue = null;
        if (document.cookie && document.cookie !== '') {
            var cookies = document.cookie.split(';');
            for (var i = 0; i < cookies.length; i++) {
                var cookie = jQuery.trim(cookies[i]);
                // Does this cookie string begin with the name we want?
                if (cookie.substring(0, name.length + 1) === (name + '=')) {
                    cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                    break;
                }
            }
        }
        return cookieValue;
    }

    function csrfSafeMethod(method) {
        // these HTTP methods do not require CSRF protection
        return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method));
    }
</script>
{% endblock %}